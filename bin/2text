#!/usr/bin/env rust-script
//! Convert files to plain text
//! ```cargo
//! [dependencies]
//! clap = { version = "4", features = ["derive"] }
//! anyhow = "1"
//! mime_guess = "2"
//! sha2 = "0.10"
//! ```

use anyhow::Result;
use clap::Parser;
use mime_guess::mime;
use sha2::{Sha256, Digest};
use std::{fs, path::Path, process::Command};

#[derive(Parser)]
#[command(about = "Convert files to plain text")]
struct Args {
    #[arg(required = true)]
    files: Vec<String>,
}

fn pandoc_convert(path: &Path, from: &str) -> Result<String> {
    let output = Command::new("pandoc")
        .args(["-f", from, "-t", "plain", "--wrap=none"])
        .arg(path)
        .output()?;

    Ok(String::from_utf8_lossy(&output.stdout).into_owned())
}

fn soffice_convert(path: &Path) -> Result<String> {
    let temp_dir = std::env::temp_dir();
    let stem = path.file_stem().unwrap().to_str().unwrap();
    let html_path = temp_dir.join(format!("{}.html", stem));

    let output = Command::new("soffice")
        .args(["--headless", "--convert-to", "html", "--outdir"])
        .arg(&temp_dir)
        .arg(path)
        .output()?;

    if !output.status.success() {
        anyhow::bail!("soffice failed: {}", String::from_utf8_lossy(&output.stderr));
    }

    if !html_path.exists() {
        anyhow::bail!("HTML file not created: {}", html_path.display());
    }

    let result = pandoc_convert(&html_path, "html");
    let _ = fs::remove_file(&html_path);
    result
}


fn file_hash(path: &Path) -> Result<String> {
    let content = fs::read(path)?;
    let hash = Sha256::digest(&content);
    Ok(format!("{:x}", hash))
}

fn convert(path: &Path) -> Result<String> {
    let hash = file_hash(path)?;
    let cache_path = path.with_extension(format!("{}.{}.2text",
        path.extension().unwrap_or_default().to_str().unwrap_or(""),
        &hash[..8])); // First 8 chars of hash

    // Check if cache exists
    if cache_path.exists() {
        if let Ok(cached) = fs::read_to_string(&cache_path) {
            return Ok(cached);
        }
    }

    // Not cached, convert and save
    let result = convert_impl(path)?;
    let _ = fs::write(&cache_path, &result);
    Ok(result)
}

fn convert_impl(path: &Path) -> Result<String> {
    let mime = mime_guess::from_path(path).first_or_text_plain();

    match (mime.type_(), mime.subtype().as_str()) {
        (mime::TEXT, "html") => pandoc_convert(path, "html"),
        (mime::TEXT, _) => Ok(fs::read_to_string(path)?),
        (mime::APPLICATION, "pdf") => Command::new("pdftotext")
            .args(["-layout", path.to_str().unwrap(), "-"])
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).into_owned())
            .map_err(Into::into),
        (mime::APPLICATION, s) if s.contains("word") => soffice_convert(path),
        (mime::APPLICATION, s) if s.contains("opendocument") => soffice_convert(path),
        (mime::APPLICATION, "rtf") => soffice_convert(path),
        (mime::APPLICATION, s) if s.contains("excel") => soffice_convert(path),
        (mime::APPLICATION, s) if s.contains("powerpoint") => soffice_convert(path),
        (mime::APPLICATION, s) if s.contains("epub") => pandoc_convert(path, "epub"),
        (mime::IMAGE, _) => Command::new("tesseract")
            .args([path.to_str().unwrap(), "stdout"])
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).into_owned())
            .map_err(Into::into),
        _ => anyhow::bail!("Unsupported: {}", mime),
    }
}

fn main() -> Result<()> {
    let args = Args::parse();
    let paths: Vec<_> = args.files.iter().map(Path::new).collect();

    for path in &paths {
        print!("{}", convert(path)?);
    }

    Ok(())
}
